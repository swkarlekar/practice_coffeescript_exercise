// Generated by CoffeeScript 2.5.1
(function() {
  var indexOf = [].indexOf;

  $(function() {
    var Grouper;
    Grouper = {
      data: {
        students: {},
        all_possible_groups: {},
        groups: {},
        group_partitions: {},
        my_response: {}
      },
      initialize: function() {
        this.setStudentData();
        return this.setNewScreen();
      },
      compute: function() {
        this.defineGroupBoundaries();
        this.findPermutationsOfStudents();
        this.checkPermutations();
        return this.displayResponse();
      },
      setStudentData: function() {
        return this.data.students = JSON.parse($("input[name='json_input']").val());
      },
      setNewScreen: function() {
        $("form").hide();
        return $(".alerts").removeClass("welcome").show();
      },
      displayResponse: function() {
        console.log(this.data.my_response);
        return $(".alerts").text(`${JSON.stringify(this.data.my_response)}`);
      },
      defineGroupBoundaries: function() {
        var num_groups, num_students, x;
        num_groups = this.data.students.groups;
        num_students = this.data.students.students.length;
        this.data.group_partitions = ((function() {
          var k, ref, ref1, results;
          results = [];
          for (x = k = 0, ref = num_students, ref1 = Math.floor(num_students / num_groups); ref1 !== 0 && (ref1 > 0 ? k <= ref : k >= ref); x = k += ref1) {
            results.push(x);
          }
          return results;
        })()).slice(0, -1).concat([num_students]);
        console.log("Math.floor(num_students/num_groups): " + Math.floor(num_students / num_groups));
        console.log("x for x in [0..num_students-1]: " + ((function() {
          var k, ref, results;
          results = [];
          for (x = k = 0, ref = num_students; (0 <= ref ? k <= ref : k >= ref); x = 0 <= ref ? ++k : --k) {
            results.push(x);
          }
          return results;
        })()));
        return console.log("@data.group_partitions " + this.data.group_partitions);
      },
      findPermutationsOfStudents: function() {
        var arr, perm;
        perm = function(xs) {
          var i, j, rest, ret;
          ret = [];
          i = 0;
          while (i < xs.length) {
            rest = perm(xs.slice(0, i).concat(xs.slice(i + 1)));
            if (!rest.length) {
              ret.push([xs[i]]);
            } else {
              j = 0;
              while (j < rest.length) {
                ret.push([xs[i]].concat(rest[j]));
                j = j + 1;
              }
            }
            i = i + 1;
          }
          return ret;
        };
        arr = this.data.students.students;
        return this.data.all_possible_groups = perm(arr);
      },
      checkPermutations: function() {
        var group_of_interest, index, names_of_group, student;
        group_of_interest = this.findFirstValidPermutation();
        if (group_of_interest === null) {
          return this.data.my_response = {
            error: "UNPOSSIBLE!"
          };
        } else {
          names_of_group = (function() {
            var k, len, results;
            results = [];
            for (k = 0, len = group_of_interest.length; k < len; k++) {
              student = group_of_interest[k];
              results.push(student.name);
            }
            return results;
          })();
          return this.data.my_response = (function() {
            var k, ref, results;
            results = [];
            for (index = k = 0, ref = this.data.group_partitions.length - 1; (0 <= ref ? k < ref : k > ref); index = 0 <= ref ? ++k : --k) {
              results.push(names_of_group.slice(this.data.group_partitions[index], this.data.group_partitions[index + 1]));
            }
            return results;
          }).call(this);
        }
      },
      findFirstValidPermutation: function() {
        var checkCannotGetAlong, countNoisy, countUnderstandMaterial, group, index, isSubgroupValid, isTrue, k, len, ref;
        countNoisy = function(xs) {
          var k, len, student, total_count_noisy;
          total_count_noisy = 0;
          for (k = 0, len = xs.length; k < len; k++) {
            student = xs[k];
            if (student.noisy === true) {
              total_count_noisy++;
            }
          }
          return total_count_noisy;
        };
        countUnderstandMaterial = function(xs) {
          var k, len, student, total_count_understands;
          total_count_understands = 0;
          for (k = 0, len = xs.length; k < len; k++) {
            student = xs[k];
            if (student.understands === true) {
              total_count_understands++;
            }
          }
          return total_count_understands;
        };
        checkCannotGetAlong = function(xs) {
          var cannotGetAlong, k, l, len, len1, names_in_group, opponent, ref, student;
          cannotGetAlong = false;
          names_in_group = (function() {
            var k, len, results;
            results = [];
            for (k = 0, len = xs.length; k < len; k++) {
              student = xs[k];
              results.push(student.name);
            }
            return results;
          })();
          for (k = 0, len = xs.length; k < len; k++) {
            student = xs[k];
            ref = student.fights_with;
            for (l = 0, len1 = ref.length; l < len1; l++) {
              opponent = ref[l];
              if (indexOf.call(names_in_group, opponent) >= 0) {
                cannotGetAlong = true;
              }
            }
          }
          return cannotGetAlong;
        };
        isSubgroupValid = function(current_group) {
          return ((countNoisy(current_group)) <= 2) && ((countUnderstandMaterial(current_group)) >= 1) && !(checkCannotGetAlong(current_group));
        };
        isTrue = function(element, index, array) {
          return element;
        };
        ref = this.data.all_possible_groups;
        for (k = 0, len = ref.length; k < len; k++) {
          group = ref[k];
          if (((function() {
            var l, ref1, results;
            results = [];
            for (index = l = 0, ref1 = this.data.group_partitions.length - 1; (0 <= ref1 ? l < ref1 : l > ref1); index = 0 <= ref1 ? ++l : --l) {
              results.push(isSubgroupValid(group.slice(this.data.group_partitions[index], this.data.group_partitions[index + 1])));
            }
            return results;
          }).call(this)).every(isTrue)) {
            return group;
          }
        }
        return null;
      },
      showAlert: function(msg) {
        return $(".alerts").text(msg).slideDown();
      }
    };
    return $("form").on("submit", function(evt) {
      var $inputs, dataNotEntered;
      evt.preventDefault();
      $inputs = $("input[type='text']");
      dataNotEntered = $inputs.filter(function() {
        return this.value.trim() !== "";
      }).length !== 1;
      if (dataNotEntered) {
        return Grouper.showAlert("Data cannot be empty");
      } else {
        Grouper.initialize();
        return Grouper.compute();
      }
    });
  });

}).call(this);
